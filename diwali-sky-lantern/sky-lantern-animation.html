<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic 3D Sky Lanterns - WorkingWithSmile</title>
    <style>
        /* Code by WorkingWithSmile YouTube Channel - https://www.youtube.com/@workingwithsmile */
        body { margin: 0; background-color: #0b1a3d; overflow: hidden;} /* Darker night background */
        canvas { display: block; }

        /* --- REDESIGNED CSS for the Dynamic Diwali Greeting --- */
        #diwali-greeting {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            
            /* Festive Font and Size - Base Responsive Size */
            font-family: 'Brush Script MT', 'Lucida Handwriting', cursive;
            font-size: 7.5vw; 
            font-weight: bold;
            text-transform: uppercase;
            color: #fff8e1; /* Off-white for core light */
            
            text-align: center; 

            opacity: 0; /* Initially hidden */
            transition: opacity 1.5s ease-in-out, transform 1.5s ease-in-out; 
            pointer-events: none; 
            z-index: 100; 
            letter-spacing: 0.1em;
            
            /* Start state for explosive scale */
            transform: translate(-50%, -50%) scale(0.9);
        }

        /* --- Media Queries for Responsive Control --- */
        
        /* 1. Mobile devices (under 600px wide): Set a reasonable minimum size */
        @media (max-width: 600px) {
            #diwali-greeting {
                font-size: 10vw; /* Slightly larger viewport unit for mobile legibility */
            }
        }
        
        /* 2. Large Desktop screens (over 1200px wide): Cap the maximum size */
        @media (min-width: 1200px) {
            #diwali-greeting {
                font-size: 90px; /* Fixed maximum size to prevent excessive scaling on huge screens */
            }
        }

        /* --- Active state when JS adds the 'show' class --- */
        #diwali-greeting.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1); /* Explode to full size */
            animation: diwaliPulse 1.5s infinite alternate; /* Start the flickering glow */
        }

        /* --- Keyframe Animation for the Pulsating Fire Glow --- */
        @keyframes diwaliPulse {
            0% {
                text-shadow: 
                    0 0 10px #ffbb00, /* Soft core glow */
                    0 0 25px #ff7300, /* Orange halo */
                    0 0 40px #ff3300; /* Red outer glow */
            }
            100% {
                text-shadow: 
                    0 0 12px #ffe57f,
                    0 0 30px #ff8800, 
                    0 0 55px #ff4400;
            }
        }
    </style>
    <!-- CORE THREE.JS DEPENDENCIES --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- REMOVED POST-PROCESSING DEPENDENCIES -->
</head>
<body>
    <!-- Code by WorkingWithSmile YouTube Channel - https://www.youtube.com/@workingwithsmile -->
    <!-- 7. Diwali Greeting Overlay Element --><div id="diwali-greeting">✨<br>Happy<br>Diwali<br>✨</div>
    
    <!-- Main script execution --><script>
        // NOTE: THREE and OrbitControls are now globally available
        
        // --- 1. Setup Scene, Camera, and Renderer ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000); 
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); 
        renderer.setClearColor(0x0b1a3d, 1); 

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        // --- POST-PROCESSING SETUP (REMOVED: Composer and Passes) ---

        // --- CAMERA CONTROLS ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement); 
        controls.enableDamping = true; // Smoother controls
        controls.dampingFactor = 0.05;

        // --- 2. Lighting Setup ---

        // Directional Light for outside shading and shadows (Simulates moon/ambient light)
        const shadowLight = new THREE.DirectionalLight(0xffffff, 0.3);
        shadowLight.position.set(2, 10, 5); 
        shadowLight.castShadow = true;
        
        shadowLight.shadow.mapSize.width = 1024;
        shadowLight.shadow.mapSize.height = 1024;
        shadowLight.shadow.camera.near = 0.5;
        shadowLight.shadow.camera.far = 50;
        shadowLight.shadow.camera.left = -10;
        shadowLight.shadow.camera.right = 10;
        shadowLight.shadow.camera.top = 10;
        shadowLight.shadow.camera.bottom = -10;
        scene.add(shadowLight);

        // Soft Ambient Light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambientLight);

        // --- Global Clock and Time Setup ---
        const clock = new THREE.Clock();
        let time = 0; 
        const MAX_LIGHT_DISTANCE = 50; 
        const MAX_LANTERNS = 20; 

        // --- 3. Starry Background Creation ---
        function createDiamondTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');

            const center = 32;
            const radius = 30;

            // Draw a soft radial gradient circle for realistic star glow
            const gradient = context.createRadialGradient(center, center, 0, center, center, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); // Bright core
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)'); // Fading edge

            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            
            return new THREE.CanvasTexture(canvas);
        }

        function createStarryBackground() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 20000; 
            const positions = [];

            for (let i = 0; i < starCount; i++) {
                const x = (Math.random() - 0.5) * 400;
                const y = (Math.random() - 0.5) * 400;
                const z = (Math.random() - 0.5) * 400;
                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            // Star Material reverted to simple setting since Bloom is gone
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff, // White
                size: 0.8, 
                transparent: true,
                blending: THREE.AdditiveBlending, 
                sizeAttenuation: true, 
                map: createDiamondTexture()
            });

            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        createStarryBackground();
        
        // --- LANTERN CONSTANTS ---
        const lanternHeight = 3.5;
        const lanternBottomY = -lanternHeight / 2; 
        const gapSize = 0.1;
        const burnerHeight = 0.15;
        const burnerTopY = lanternBottomY - gapSize; 
        const stringHeight = gapSize + 0.05; 
        const stringRadius = 0.005;
        const stringOffset = 0.6; 

        const festiveColors = [
            0xfd8d3c, // Orange
            0xe74c3c, // Red
            0x9b59b6, // Purple
            0x3498db, // Blue
            0xf1c40f, // Yellow
            0x2ecc71  // Green
        ];

        const activeLanterns = [];

        // --- 4. Create the 3D Sky Lantern Function ---
        function createSkyLantern(initialX, initialY, initialZ, color) {
            const lanternGroup = new THREE.Group();
            lanternGroup.userData.floatSpeed = 0.005 + Math.random() * 0.015; 
            
            lanternGroup.rotation.x = Math.PI / 12; 
            
            // 4a. Lantern Body (Realistic shape using LatheGeometry)
            const lanternPoints = [];
            const segments = 10;
            for (let i = 0; i <= segments; i++) {
                const y = (i / segments) * lanternHeight;
                let radius;
                if (i <= 3) {
                    radius = THREE.MathUtils.lerp(1.1, 1.3, i / 3);
                } else if (i <= 7) {
                    radius = 1.3 + Math.sin((i - 3) / 4 * Math.PI) * 0.1; 
                } else {
                    radius = THREE.MathUtils.lerp(1.4, 0.7, (i - 7) / 3);
                }
                lanternPoints.push(new THREE.Vector2(radius, y - (lanternHeight / 2)));
            }

            const bodyGeometry = new THREE.LatheGeometry(lanternPoints, 32); 
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: color, 
                transparent: true,
                opacity: 0.8,
                roughness: 0.9, 
                side: THREE.DoubleSide,
                emissive: new THREE.Color(color).multiplyScalar(0.6), // Emissive based on main color
                emissiveIntensity: 3.5 
            });
            const lanternBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            lanternBody.castShadow = true; 
            lanternBody.receiveShadow = true; 
            lanternGroup.add(lanternBody);

            // 4b. Burner/Basket (Bottom structure)
            const burnerGeometry = new THREE.BoxGeometry(1.5, burnerHeight, 1.5);
            const burnerMaterial = new THREE.MeshStandardMaterial({ color: 0x4a2a1a, roughness: 0.8 }); 
            const lanternBurner = new THREE.Mesh(burnerGeometry, burnerMaterial);
            lanternBurner.position.y = burnerTopY - (burnerHeight / 2); 
            lanternBurner.castShadow = true;
            lanternBurner.receiveShadow = true;
            lanternGroup.add(lanternBurner);

            // 4c. Internal Light (Flame effect - Light source)
            const flameLight = new THREE.PointLight(0xffaa00, 5, 8); 
            flameLight.position.y = burnerTopY + 0.3; 
            flameLight.decay = 1.5; 
            flameLight.castShadow = false; 
            lanternGroup.add(flameLight);
            lanternGroup.userData.flameLight = flameLight; 

            // 4d. Visible 3D Flame (Cone geometry with bright emissive material)
            const visibleFlame = new THREE.Mesh(
                new THREE.ConeGeometry(0.2, 0.6, 16), 
                new THREE.MeshBasicMaterial({
                    color: 0xffe600, 
                    emissive: 0xffa500, 
                    emissiveIntensity: 2.0, 
                    transparent: true,
                    opacity: 0.9
                })
            );
            visibleFlame.position.y = burnerTopY + 0.3; 
            lanternGroup.add(visibleFlame);
            lanternGroup.userData.visibleFlame = visibleFlame; 

            // 4e. Connecting Strings (Four thin cylinders)
            const stringGeometry = new THREE.CylinderGeometry(stringRadius, stringRadius, stringHeight, 8);
            const stringMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 1.0 });
            const stringPositions = [
                { x: stringOffset, z: stringOffset },
                { x: -stringOffset, z: stringOffset },
                { x: stringOffset, z: -stringOffset },
                { x: -stringOffset, z: -stringOffset }
            ];
            const stringCenterY = (lanternBottomY + burnerTopY) / 2;
            stringPositions.forEach(pos => {
                const string = new THREE.Mesh(stringGeometry, stringMaterial);
                string.position.set(pos.x, stringCenterY, pos.z);
                string.castShadow = true;
                lanternGroup.add(string);
            });

            // Set initial position
            lanternGroup.position.set(initialX, initialY, initialZ);
            lanternGroup.userData.initialSpawnTime = time; 
            scene.add(lanternGroup);
            activeLanterns.push(lanternGroup); 
        }

        // --- GROUND PLANE MODIFIED: Match Background for Seamless Look ---
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x0b1a3d, 
            transparent: true,
            opacity: 0.2, 
            depthWrite: false 
        }); 
        
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -5;
        
        plane.receiveShadow = true; 
        plane.castShadow = false; 
        scene.add(plane);


        // --- Initial Lanterns (optional, for immediate view) ---
        for (let i = 0; i < 5; i++) {
            const x = (Math.random() - 0.5) * 10; 
            const y = (Math.random() - 0.5) * 5;  
            const z = (Math.random() - 0.5) * 10; 
            const color = festiveColors[Math.floor(Math.random() * festiveColors.length)];
            createSkyLantern(x, y, z, color);
        }
        
        // Camera position for a nice initial frontal view
        camera.position.set(0, 0, 15); 
        camera.lookAt(0, 0, 0); 


        // --- 5. Animation Loop ---
        let spawnTimer = 0;
        const spawnInterval = 1.0; 

        function animate() {
            requestAnimationFrame(animate);

            controls.update(); 

            const delta = clock.getDelta();
            time += delta; 

            // Lantern Spawning Logic with HARD CAP
            spawnTimer += delta;
            if (activeLanterns.length < MAX_LANTERNS && spawnTimer >= spawnInterval + Math.random() * 0.5) { 
                const x = (Math.random() - 0.5) * 40; 
                const y = -10; 
                const z = (Math.random() - 0.5) * 40; 
                const color = festiveColors[Math.floor(Math.random() * festiveColors.length)];
                createSkyLantern(x, y, z, color);
                spawnTimer = 0;
            }

            // Update all active lanterns
            for (let i = activeLanterns.length - 1; i >= 0; i--) {
                const lantern = activeLanterns[i];

                const distance = camera.position.distanceTo(lantern.position);
                if (distance < MAX_LIGHT_DISTANCE) {
                    lantern.userData.flameLight.visible = true;
                    
                    // Flicker effect on internal light intensity
                    lantern.userData.flameLight.intensity = 4 + Math.sin(time * 10 + i) * 1.5 + Math.random() * 0.5;
                } else {
                    lantern.userData.flameLight.visible = false;
                }

                // Upward movement
                lantern.position.y += lantern.userData.floatSpeed * delta * 60; 

                // Gentle rotation 
                lantern.rotation.y += 0.005 * delta * 60;
                
                // Subtle vertical scaling/flicker on the visible flame
                lantern.userData.visibleFlame.scale.y = 1 + Math.sin(time * 15 + i) * 0.1;

                // Despawn lanterns that are too high
                if (lantern.position.y > 20) {
                    scene.remove(lantern);
                    lantern.traverse(object => {
                        if (object.isMesh) {
                            object.geometry.dispose();
                            object.material.dispose();
                        }
                    });
                    activeLanterns.splice(i, 1);
                }
            }

            // RESTORED SIMPLE RENDERER RENDER
            renderer.render(scene, camera);
        }

        // --- 6. Handle Window Resizing ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // REMOVED COMPOSER RESIZE CALLS
        });
        
        animate();

        // --- 7. Diwali Greeting Overlay ---
        const greetingElement = document.getElementById('diwali-greeting');

        setTimeout(() => {
            if (greetingElement) {
                greetingElement.classList.add('show');
            }
        }, 5000); 
        // Code by WorkingWithSmile YouTube Channel - https://www.youtube.com/@workingwithsmile
    </script>
    <!-- Code by WorkingWithSmile YouTube Channel - https://www.youtube.com/@workingwithsmile -->
</body>
</html>
